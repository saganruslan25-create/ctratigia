/**
 * @license
 * SPDX-License-Identifier: Apache-2.0
 */

import React, { useState, useEffect, useRef, useCallback } from 'react';
import { initializeApp } from 'firebase/app';
import { 
  getFirestore, doc, setDoc, getDoc, updateDoc, onSnapshot, 
  deleteDoc, collection, getDocs, serverTimestamp 
} from 'firebase/firestore';
import { 
  getAuth, signInAnonymously, onAuthStateChanged, 
  signInWithEmailAndPassword, createUserWithEmailAndPassword, 
  signOut, updateProfile 
} from 'firebase/auth';
import { motion, AnimatePresence } from 'motion/react';
import { 
  Sword, Users, Cpu, Map as MapIcon, Settings, LogOut, 
  Plus, Play, X, Copy, Shield, Zap, Target, RefreshCw,
  Trash2, Undo2, Save, Image as ImageIcon, MousePointer2,
  Eraser, PaintBucket, Move, Waves, Landmark, TreeDeciduous,
  Milestone, Building2, Home, Ghost
} from 'lucide-react';

// --- CONFIG & CONSTANTS ---
const firebaseConfig = {
  apiKey: "AIzaSyAXTOcA4I5AYP0jfbVWb1de-lZjwf1DRhc",
  authDomain: "ctratigia.firebaseapp.com",
  projectId: "ctratigia",
  storageBucket: "ctratigia.firebasestorage.app",
  messagingSenderId: "71283939831",
  appId: "1:71283939831:web:6725da39c4b58c0065b6f2"
};

const fbApp = initializeApp(firebaseConfig);
const db = getFirestore(fbApp);
const auth = getAuth(fbApp);

const UNIT_DEFS = {
  infantry: { name: '–ü—ñ—Ö–æ—Ç–∞', emoji: 'üë•', radius: 8, hp: 100, maxHp: 100, atk: 12, def: 5, speed: 18, range: 40, cost: 150 },
  apc: { name: '–ë–¢–†', emoji: 'üöõ', radius: 10, hp: 200, maxHp: 200, atk: 20, def: 15, speed: 28, range: 50, cost: 350 },
  tank: { name: '–¢–∞–Ω–∫', emoji: 'üõ°Ô∏è', radius: 12, hp: 350, maxHp: 350, atk: 40, def: 30, speed: 20, range: 60, cost: 600 },
  heli: { name: '–ì–µ–ª—ñ–∫–æ–ø—Ç–µ—Ä', emoji: 'üöÅ', radius: 9, hp: 150, maxHp: 150, atk: 35, def: 5, speed: 55, range: 80, cost: 500 },
  artillery: { name: '–ê—Ä—Ç–∏–ª–µ—Ä—ñ—è', emoji: 'üí•', radius: 8, hp: 120, maxHp: 120, atk: 70, def: 3, speed: 10, range: 200, cost: 700 },
  stinger: { name: '–°—Ç—Ä—ñ–ª–µ—Ü—å ¬´–°–º–µ—Ä—á¬ª', emoji: 'üöÄ', radius: 8, hp: 90, maxHp: 90, atk: 95, def: 2, speed: 8, range: 380, cost: 850, isMissile: true },
};

const CL_CLOUD = 'dimpa9w8w';
const CL_PRESET = 'ctratigia_map';

// --- TYPES ---
type Team = 'blue' | 'red' | 'neutral';
type UnitState = 'idle' | 'moving' | 'attack' | 'patrol' | 'defend' | 'advance' | 'front' | 'force_attack' | 'hold';

interface Unit {
  id: number;
  type: keyof typeof UNIT_DEFS;
  owner: Team;
  x: number;
  y: number;
  tx?: number;
  ty?: number;
  hp: number;
  maxHp: number;
  atk: number;
  def: number;
  speed: number;
  range: number;
  radius: number;
  state: UnitState;
  attackTarget?: number;
  forceTarget?: number;
  moveTarget?: { x: number, y: number } | null;
  patrolA?: { x: number, y: number } | null;
  patrolB?: { x: number, y: number } | null;
  patrolDir?: number;
  defendX?: number;
  defendY?: number;
  lastAttack: number;
  lastAttackAnim: number;
  _dead?: boolean;
}

interface City {
  id: string;
  name: string;
  x: number;
  y: number;
  nx: number;
  ny: number;
  owner: Team;
  income: number;
  hp: number;
  maxHp: number;
  captureProgress: { blue: number, red: number };
}

// --- MAIN COMPONENT ---
export default function App() {
  const [screen, setScreen] = useState<'loading' | 'menu' | 'lobby' | 'game' | 'editor' | 'admin'>('loading');
  const [user, setUser] = useState<any>(null);
  const [isAdmin, setIsAdmin] = useState(false);
  const [lobby, setLobby] = useState<any>(null);
  const [myRole, setMyRole] = useState<Team | null>(null);
  const [globalMaps, setGlobalMaps] = useState<any[]>([]);
  const [gameData, setGameData] = useState<any>({
    units: [],
    funds: { blue: 2000, red: 2000 },
    casualties: { blue: 0, red: 0 },
    cities: [],
    phase: 'placement',
    wave: 1,
    timer: 0
  });

  // Refs for Game Engine
  const canvasRefs = {
    map: useRef<HTMLCanvasElement>(null),
    units: useRef<HTMLCanvasElement>(null),
    front: useRef<HTMLCanvasElement>(null),
    ui: useRef<HTMLCanvasElement>(null),
    inter: useRef<HTMLCanvasElement>(null)
  };
  
  const engineState = useRef({
    camX: 0, camY: 0, camScale: 1,
    mapBg: null as HTMLImageElement | null,
    mapW: 2000, mapH: 1200,
    isDragging: false, dragLX: 0, dragLY: 0,
    selectedUnitIds: new Set<number>(),
    placingType: null as keyof typeof UNIT_DEFS | null,
    inputMode: 'move' as 'move' | 'attack' | 'patrol',
    projectiles: [] as any[],
    lastFrame: 0,
    isAI: false,
    aiMode: 'defense',
    terrain: { roads: [], forests: [], water: [], bridges: [] } as any
  });

  // --- INITIALIZATION ---
  useEffect(() => {
    const unsub = onAuthStateChanged(auth, async (u) => {
      if (u) {
        setUser(u);
        const usnap = await getDoc(doc(db, 'users', u.uid));
        setIsAdmin(usnap.exists() && usnap.data().role === 'admin');
        loadGlobalMaps();
        setScreen('menu');
      } else {
        signInAnonymously(auth);
      }
    });
    return unsub;
  }, []);

  useEffect(() => {
    if (screen === 'game') {
      // Initialize cities and units
      const mw = engineState.current.mapW;
      const mh = engineState.current.mapH;
      
      const initialCities: City[] = [
        { id: 'c1', name: '–¶–µ–Ω—Ç—Ä', x: mw * 0.5, y: mh * 0.5, nx: 0.5, ny: 0.5, owner: 'neutral', income: 150, hp: 300, maxHp: 300, captureProgress: { blue: 0, red: 0 } },
        { id: 'c2', name: '–ó–∞—Ö—ñ–¥', x: mw * 0.25, y: mh * 0.4, nx: 0.25, ny: 0.4, owner: 'neutral', income: 150, hp: 300, maxHp: 300, captureProgress: { blue: 0, red: 0 } },
        { id: 'c3', name: '–°—Ö—ñ–¥', x: mw * 0.75, y: mh * 0.6, nx: 0.75, ny: 0.6, owner: 'neutral', income: 150, hp: 300, maxHp: 300, captureProgress: { blue: 0, red: 0 } },
      ];

      const initialUnits: Unit[] = [
        { id: 1, type: 'infantry', owner: 'blue', x: mw * 0.1, y: mh * 0.5, hp: 100, maxHp: 100, atk: 12, def: 5, speed: 18, range: 40, radius: 8, state: 'idle', lastAttack: 0, lastAttackAnim: 0 },
        { id: 2, type: 'apc', owner: 'blue', x: mw * 0.1, y: mh * 0.4, hp: 200, maxHp: 200, atk: 20, def: 15, speed: 28, range: 50, radius: 10, state: 'idle', lastAttack: 0, lastAttackAnim: 0 },
      ];

      if (engineState.current.isAI) {
        initialUnits.push(
          { id: 101, type: 'infantry', owner: 'red', x: mw * 0.9, y: mh * 0.5, hp: 100, maxHp: 100, atk: 12, def: 5, speed: 18, range: 40, radius: 8, state: 'idle', lastAttack: 0, lastAttackAnim: 0 },
          { id: 102, type: 'tank', owner: 'red', x: mw * 0.9, y: mh * 0.6, hp: 350, maxHp: 350, atk: 40, def: 30, speed: 20, range: 60, radius: 12, state: 'idle', lastAttack: 0, lastAttackAnim: 0 }
        );
      }

      setGameData((prev: any) => ({
        ...prev,
        cities: initialCities,
        units: initialUnits,
        timer: 0,
        phase: 'placement'
      }));
      
      // Auto-center camera
      const area = canvasRefs.inter.current?.parentElement;
      if (area) {
        const sc = Math.min(area.clientWidth / mw, area.clientHeight / mh, 0.9);
        engineState.current.camScale = sc;
        engineState.current.camX = (area.clientWidth - mw * sc) / 2;
        engineState.current.camY = (area.clientHeight - mh * sc) / 2;
      }
    }
  }, [screen]);

  const loadGlobalMaps = async () => {
    const snap = await getDoc(doc(db, 'appData', 'globalMaps'));
    if (snap.exists()) setGlobalMaps(snap.data().maps || []);
  };

  // --- TIMERS ---
  useEffect(() => {
    if (screen === 'game') {
      const gameTimer = setInterval(() => {
        setGameData((prev: any) => ({ ...prev, timer: prev.timer + 1 }));
      }, 1000);

      const incomeTimer = setInterval(() => {
        setGameData((prev: any) => {
          const baseIncome = 200;
          const cityBonus = prev.cities.filter((c: any) => c.owner === myRole).length * 150;
          const total = baseIncome + cityBonus;
          
          // Visual feedback
          toast(`üí∞ –î–æ—Ö—ñ–¥: +${total} ‚Ç¥`);
          
          return {
            ...prev,
            funds: { ...prev.funds, [myRole!]: prev.funds[myRole!] + total }
          };
        });
      }, 15000);

      return () => {
        clearInterval(gameTimer);
        clearInterval(incomeTimer);
      };
    }
  }, [screen, myRole]);

  // --- GAME ENGINE LOGIC ---
  const drawAll = useCallback(() => {
    const { camX, camY, camScale, mapBg, mapW, mapH } = engineState.current;
    
    // 1. Map Layer
    const mCtx = canvasRefs.map.current?.getContext('2d');
    if (mCtx) {
      mCtx.clearRect(0, 0, mCtx.canvas.width, mCtx.canvas.height);
      mCtx.fillStyle = '#06090d';
      mCtx.fillRect(0, 0, mCtx.canvas.width, mCtx.canvas.height);
      mCtx.save();
      mCtx.translate(camX, camY);
      mCtx.scale(camScale, camScale);
      if (mapBg) mCtx.drawImage(mapBg, 0, 0, mapW, mapH);
      
      // Draw Cities
      gameData.cities.forEach((c: City) => {
        mCtx.font = '24px serif';
        mCtx.textAlign = 'center';
        mCtx.fillText('üèôÔ∏è', c.x, c.y);
        mCtx.beginPath();
        mCtx.arc(c.x, c.y, 20, 0, Math.PI * 2);
        mCtx.strokeStyle = c.owner === 'blue' ? '#3b82f6' : c.owner === 'red' ? '#ef4444' : '#94a3b8';
        mCtx.lineWidth = 2;
        mCtx.stroke();
      });
      mCtx.restore();
    }

    // 2. Units Layer
    const uCtx = canvasRefs.units.current?.getContext('2d');
    if (uCtx) {
      uCtx.clearRect(0, 0, uCtx.canvas.width, uCtx.canvas.height);
      uCtx.save();
      uCtx.translate(camX, camY);
      uCtx.scale(camScale, camScale);
      gameData.units.forEach((u: Unit) => {
        const def = UNIT_DEFS[u.type];
        const isBlue = u.owner === 'blue';
        const isSel = engineState.current.selectedUnitIds.has(u.id);
        
        if (isSel) {
          uCtx.beginPath();
          uCtx.arc(u.x, u.y, u.radius + 5, 0, Math.PI * 2);
          uCtx.strokeStyle = '#fff';
          uCtx.stroke();
        }
        
        uCtx.beginPath();
        uCtx.arc(u.x, u.y, u.radius, 0, Math.PI * 2);
        uCtx.fillStyle = isBlue ? '#1d4ed8' : '#b91c1c';
        uCtx.fill();
        uCtx.font = `${u.radius}px serif`;
        uCtx.textAlign = 'center';
        uCtx.textBaseline = 'middle';
        uCtx.fillStyle = '#fff';
        uCtx.fillText(def.emoji, u.x, u.y);
        
        // HP Bar
        uCtx.fillStyle = '#000';
        uCtx.fillRect(u.x - 10, u.y - u.radius - 5, 20, 3);
        uCtx.fillStyle = '#22c55e';
        uCtx.fillRect(u.x - 10, u.y - u.radius - 5, 20 * (u.hp / u.maxHp), 3);
      });
      uCtx.restore();
    }
  }, [gameData, canvasRefs]);

  useEffect(() => {
    if (screen === 'game') {
      const loop = (ts: number) => {
        const dt = Math.min((ts - engineState.current.lastFrame) / 1000, 0.05);
        engineState.current.lastFrame = ts;
        
        if (gameData.phase === 'battle') {
          updateGameLogic(dt);
        }
        
        drawAll();
        requestAnimationFrame(loop);
      };
      requestAnimationFrame(loop);
    }
  }, [screen, gameData.phase, drawAll]);

  const updateGameLogic = (dt: number) => {
    const now = Date.now();
    
    setGameData((prev: any) => {
      let newUnits = [...prev.units];
      const newCities = [...prev.cities];
      
      // 1. Unit Logic (Movement & Combat)
      newUnits = newUnits.map((u: Unit) => {
        if (u._dead) return u;
        
        let nextU = { ...u };
        const enemies = newUnits.filter(e => e.owner !== u.owner && !e._dead);
        
        // Find nearest enemy
        let nearestEnemy = null;
        let minDist = Infinity;
        enemies.forEach(e => {
          const d = Math.hypot(e.x - u.x, e.y - u.y);
          if (d < minDist) { minDist = d; nearestEnemy = e; }
        });

        // Attack logic
        if (nearestEnemy && minDist <= u.range) {
          if (now - u.lastAttack > 1000) {
            nextU.lastAttack = now;
            nextU.lastAttackAnim = now;
            nextU.attackTarget = nearestEnemy.id;
            // Damage calculation
            const targetIdx = newUnits.findIndex(v => v.id === nearestEnemy.id);
            if (targetIdx !== -1) {
              const dmg = Math.max(1, u.atk - Math.floor(newUnits[targetIdx].def / 3));
              newUnits[targetIdx] = { ...newUnits[targetIdx], hp: newUnits[targetIdx].hp - dmg };
              if (newUnits[targetIdx].hp <= 0) newUnits[targetIdx]._dead = true;
            }
          }
        }

        // Movement logic
        if (u.moveTarget) {
          const dx = u.moveTarget.x - u.x;
          const dy = u.moveTarget.y - u.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist > 5) {
            nextU.x += (dx / dist) * u.speed * dt;
            nextU.y += (dy / dist) * u.speed * dt;
          } else {
            nextU.moveTarget = null;
          }
        } else if (engineState.current.isAI && u.owner === 'red') {
          // Simple AI: move toward player or nearest city
          const target = prev.units.find((v: any) => v.owner === 'blue') || prev.cities[0];
          if (target) {
            const dx = target.x - u.x;
            const dy = target.y - u.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist > u.range * 0.8) {
              nextU.x += (dx / dist) * u.speed * dt;
              nextU.y += (dy / dist) * u.speed * dt;
            }
          }
        }
        
        return nextU;
      });

      // 2. City Capture Logic
      newCities.forEach((city, idx) => {
        const blueNear = newUnits.filter(u => u.owner === 'blue' && !u._dead && Math.hypot(u.x - city.x, u.y - city.y) < 40).length;
        const redNear = newUnits.filter(u => u.owner === 'red' && !u._dead && Math.hypot(u.x - city.x, u.y - city.y) < 40).length;
        
        if (blueNear > 0 && redNear === 0) {
          city.captureProgress.blue = Math.min(100, city.captureProgress.blue + dt * 20);
          city.captureProgress.red = Math.max(0, city.captureProgress.red - dt * 20);
          if (city.captureProgress.blue >= 100 && city.owner !== 'blue') {
            city.owner = 'blue';
            toast(`üèôÔ∏è ${city.name} –∑–∞—Ö–æ–ø–ª–µ–Ω–æ –°–ò–ù–Ü–ú–ò!`);
          }
        } else if (redNear > 0 && blueNear === 0) {
          city.captureProgress.red = Math.min(100, city.captureProgress.red + dt * 20);
          city.captureProgress.blue = Math.max(0, city.captureProgress.blue - dt * 20);
          if (city.captureProgress.red >= 100 && city.owner !== 'red') {
            city.owner = 'red';
            toast(`üèôÔ∏è ${city.name} –∑–∞—Ö–æ–ø–ª–µ–Ω–æ –ß–ï–†–í–û–ù–ò–ú–ò!`);
          }
        }
      });

      return { 
        ...prev, 
        units: newUnits.filter(u => !u._dead || now - u.lastAttackAnim < 500),
        cities: newCities
      };
    });
  };

  // --- INTERACTION HANDLERS ---
  const handleWheel = (e: React.WheelEvent) => {
    const f = e.deltaY < 0 ? 1.15 : 0.85;
    const rect = canvasRefs.inter.current?.getBoundingClientRect();
    if (!rect) return;
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    
    const newScale = Math.max(0.05, Math.min(10, engineState.current.camScale * f));
    
    // Zoom toward mouse position
    engineState.current.camX = mx - (mx - engineState.current.camX) * (newScale / engineState.current.camScale);
    engineState.current.camY = my - (my - engineState.current.camY) * (newScale / engineState.current.camScale);
    engineState.current.camScale = newScale;
    
    drawAll();
  };

  const handleMouseDown = (e: React.MouseEvent) => {
    const rect = canvasRefs.inter.current?.getBoundingClientRect();
    if (!rect) return;
    const sx = e.clientX - rect.left;
    const sy = e.clientY - rect.top;
    const wx = (sx - engineState.current.camX) / engineState.current.camScale;
    const wy = (sy - engineState.current.camY) / engineState.current.camScale;

    if (e.button === 0) { // Left Click
      if (engineState.current.placingType) {
        placeUnit(wx, wy);
      } else {
        const clicked = gameData.units.find((u: Unit) => Math.hypot(u.x - wx, u.y - wy) < u.radius * 2);
        if (clicked && clicked.owner === myRole) {
          engineState.current.selectedUnitIds = new Set([clicked.id]);
        } else {
          engineState.current.selectedUnitIds.clear();
        }
      }
    } else if (e.button === 2) { // Right Click
      if (engineState.current.selectedUnitIds.size > 0) {
        issueMoveOrder(wx, wy);
      }
    }
  };

  const placeUnit = (wx: number, wy: number) => {
    const type = engineState.current.placingType;
    if (!type) return;
    const def = UNIT_DEFS[type];
    if (gameData.funds[myRole!] < def.cost) return;

    const newUnit: Unit = {
      id: Date.now(),
      type,
      owner: myRole!,
      x: wx, y: wy,
      hp: def.hp, maxHp: def.hp,
      atk: def.atk, def: def.def,
      speed: def.speed, range: def.range, radius: def.radius,
      state: 'idle',
      lastAttack: 0, lastAttackAnim: 0
    };

    setGameData((prev: any) => ({
      ...prev,
      units: [...prev.units, newUnit],
      funds: { ...prev.funds, [myRole!]: prev.funds[myRole!] - def.cost }
    }));
    engineState.current.placingType = null;
  };

  const issueMoveOrder = (wx: number, wy: number) => {
    setGameData((prev: any) => ({
      ...prev,
      units: prev.units.map((u: Unit) => 
        engineState.current.selectedUnitIds.has(u.id) ? { ...u, moveTarget: { x: wx, y: wy }, state: 'moving' } : u
      )
    }));
  };

  // --- RENDER SCREENS ---
  if (screen === 'loading') {
    return (
      <div className="fixed inset-0 bg-[#040608] flex flex-col items-center justify-center z-50">
        <div className="font-oswald text-3xl text-[#22c55e] tracking-[4px] mb-4">–°–¢–†–ê–¢–ï–ì–Ü–Ø</div>
        <div className="w-48 h-1 bg-white/5 rounded-full overflow-hidden">
          <div className="h-full bg-[#22c55e] animate-ld" />
        </div>
      </div>
    );
  }

  if (screen === 'menu') {
    return (
      <div className="fixed inset-0 flex flex-col items-center justify-center bg-radial-[ellipse_at_center] from-[#22c55e12] to-transparent">
        <div className="menu-bg-grid absolute inset-0" />
        <motion.div 
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          className="relative z-10 text-center mb-12"
        >
          <div className="font-oswald text-[11px] text-[#22c55e] tracking-[8px] opacity-70 mb-2">–û–ü–ï–†–ê–¶–Ü–Ø</div>
          <h1 className="font-oswald text-6xl font-bold leading-none tracking-wider bg-gradient-to-br from-white to-[#4ade80] bg-clip-text text-transparent">
            –°–¢–†–ê–¢–ï–ì–Ü–Ø
          </h1>
          <div className="text-[12px] text-[#64748b] tracking-[4px] mt-3">–¢–ê–ö–¢–ò–ß–ù–ê –ë–û–ô–û–í–ê –°–ò–°–¢–ï–ú–ê v3.1</div>
        </motion.div>

        <div className="relative z-10 flex flex-col gap-3 w-80">
          <MenuButton icon={<Sword size={18} />} label="–°–¢–í–û–†–ò–¢–ò –õ–û–ë–Ü" primary onClick={() => setScreen('lobby')} />
          <MenuButton icon={<Users size={18} />} label="–ü–†–ò–Ñ–î–ù–ê–¢–ò–°–¨" onClick={() => {}} />
          <MenuButton icon={<Cpu size={18} />} label="–ü–†–û–¢–ò –Ü–Ü" onClick={() => {
            engineState.current.isAI = true;
            setMyRole('blue');
            setScreen('game');
          }} />
          <MenuButton icon={<MapIcon size={18} />} label="–†–ï–î–ê–ö–¢–û–† –ö–ê–†–¢–ò" onClick={() => setScreen('editor')} />
          {isAdmin && <MenuButton icon={<Shield size={18} />} label="–ê–î–ú–Ü–ù –ü–ê–ù–ï–õ–¨" gold onClick={() => setScreen('admin')} />}
        </div>
      </div>
    );
  }

  if (screen === 'game') {
    return (
      <div className="fixed inset-0 flex flex-col bg-[#040608]">
        {/* HUD TOP */}
        <div className="h-12 bg-[#040608fb] border-b border-[#22c55e2e] flex items-center px-4 gap-4 z-50">
          <div className="font-oswald text-sm font-bold text-[#22c55e] tracking-wider">‚öî –°–¢–†–ê–¢–ï–ì–Ü–Ø</div>
          <div className="w-px h-5 bg-white/10" />
          <Stat label="üí∞" value={gameData.funds[myRole!] || 0} color="text-[#f59e0b]" />
          <div className="absolute left-1/2 -translate-x-1/2 flex flex-col items-center">
            <div className="font-oswald text-xl font-bold text-white tracking-widest">
              {Math.floor(gameData.timer / 60).toString().padStart(2, '0')}:{(gameData.timer % 60).toString().padStart(2, '0')}
            </div>
            <div className="text-[9px] text-[#64748b] tracking-widest uppercase">{gameData.phase === 'placement' ? '–†–æ–∑–º—ñ—â–µ–Ω–Ω—è' : '–ë—ñ–π'}</div>
          </div>
          <div className="ml-auto flex items-center gap-4">
            <Stat label="üîµ" value={gameData.units.filter((u: any) => u.owner === 'blue').length} color="text-[#3b82f6]" />
            <Stat label="üî¥" value={gameData.units.filter((u: any) => u.owner === 'red').length} color="text-[#ef4444]" />
            <button 
              onClick={() => setScreen('menu')}
              className="bg-white/5 border border-white/10 text-white px-3 py-1 rounded text-[10px] font-oswald hover:border-red-500/40 hover:text-red-400 transition-colors"
            >
              –í–ò–ô–¢–ò
            </button>
          </div>
        </div>

        <div className="flex-1 flex relative overflow-hidden">
          {/* CANVAS AREA */}
          <div className="flex-1 relative bg-[#06090d]">
            <canvas ref={canvasRefs.map} className="absolute inset-0" />
            <canvas ref={canvasRefs.units} className="absolute inset-0 pointer-events-none" />
            <canvas ref={canvasRefs.front} className="absolute inset-0 pointer-events-none" />
            <canvas ref={canvasRefs.ui} className="absolute inset-0 pointer-events-none" />
            <canvas 
              ref={canvasRefs.inter} 
              className="absolute inset-0 touch-none"
              onMouseDown={handleMouseDown}
              onWheel={handleWheel}
              onContextMenu={(e) => e.preventDefault()}
            />
            
            {/* ZOOM INDICATOR */}
            <div className="absolute bottom-4 right-4 bg-black/60 border border-white/10 px-2 py-1 rounded text-[10px] text-[#64748b]">
              {Math.round(engineState.current.camScale * 100)}%
            </div>
          </div>

          {/* SIDE PANEL */}
          <div className="w-64 bg-[#040608fb] border-l border-[#22c55e2e] flex flex-col p-4 z-40">
            <div className="text-[9px] text-[#64748b] tracking-[3px] mb-4 uppercase">–ö—É–ø–∏—Ç–∏ —é–Ω—ñ—Ç–∏</div>
            <div className="flex flex-col gap-2 overflow-y-auto pr-1">
              {Object.entries(UNIT_DEFS).map(([type, def]) => (
                <button 
                  key={type}
                  onClick={() => {
                    engineState.current.placingType = type as keyof typeof UNIT_DEFS;
                    toast(`–†–æ–∑–º—ñ—Å—Ç—ñ—Ç—å ${def.name} –Ω–∞ —Å–≤–æ—ó–π –ø–æ–ª–æ–≤–∏–Ω—ñ`);
                  }}
                  className={`flex items-center gap-3 p-2 rounded-lg border transition-all ${
                    engineState.current.placingType === type 
                      ? 'bg-[#3b82f615] border-[#3b82f64d]' 
                      : 'bg-white/5 border-white/10 hover:bg-white/10'
                  }`}
                >
                  <span className="text-xl">{def.emoji}</span>
                  <div className="flex-1 text-left">
                    <div className="text-[11px] font-bold text-white">{def.name}</div>
                    <div className="text-[9px] text-[#64748b]">HP:{def.hp} ¬∑ ATK:{def.atk}</div>
                  </div>
                  <div className="font-oswald text-xs font-bold text-[#f59e0b]">{def.cost}</div>
                </button>
              ))}
            </div>
            
            <button 
              onClick={() => setGameData((p: any) => ({ ...p, phase: 'battle' }))}
              className="mt-6 bg-[#22c55e] text-black font-oswald font-bold py-2 rounded hover:bg-[#4ade80] transition-colors"
            >
              –ü–û–ß–ê–¢–ò –ë–Ü–ô
            </button>
          </div>
        </div>
      </div>
    );
  }

  if (screen === 'editor') {
    return <Editor onBack={() => setScreen('menu')} />;
  }

  return null;
}

// --- SUB-COMPONENTS ---

function MenuButton({ icon, label, primary, gold, onClick }: any) {
  return (
    <button 
      onClick={onClick}
      className={`
        relative overflow-hidden px-6 py-3 rounded border font-oswald text-sm font-medium tracking-[2px] text-left transition-all group
        ${primary ? 'bg-[#22c55e1a] border-[#22c55e66] text-[#4ade80]' : 
          gold ? 'bg-[#f59e0b0d] border-[#f59e0b33] text-[#f59e0b]' : 
          'bg-white/[0.02] border-white/[0.08] text-[#e2e8f0] hover:border-[#22c55e4d] hover:bg-[#22c55e0d]'}
      `}
    >
      <div className="absolute left-0 top-0 bottom-0 w-1 bg-[#22c55e] scale-y-0 group-hover:scale-y-100 transition-transform" />
      <span className="inline-block mr-3 opacity-70">{icon}</span>
      {label}
    </button>
  );
}

function Stat({ label, value, color }: any) {
  return (
    <div className="flex items-center gap-2">
      <span className="text-[9px] text-[#64748b] tracking-widest">{label}</span>
      <span className={`font-oswald text-sm font-bold ${color}`}>{value}</span>
    </div>
  );
}

function Editor({ onBack }: { onBack: () => void }) {
  const [tool, setTool] = useState('draw');
  const [brushSize, setBrushSize] = useState(14);
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const ctxRef = useRef<CanvasRenderingContext2D | null>(null);
  const [bg, setBg] = useState<HTMLImageElement | null>(null);
  const [zoom, setZoom] = useState(1);
  const [cam, setCam] = useState({ x: 0, y: 0 });
  const [isDrawing, setIsDrawing] = useState(false);
  const lastPos = useRef({ x: 0, y: 0 });

  useEffect(() => {
    const cv = canvasRef.current;
    if (cv) {
      ctxRef.current = cv.getContext('2d');
      // Initial background
      if (ctxRef.current) {
        ctxRef.current.fillStyle = '#1a2810';
        ctxRef.current.fillRect(0, 0, cv.width, cv.height);
      }
    }
  }, []);

  const handleFile = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (!file) return;
    const img = new Image();
    img.onload = () => {
      setBg(img);
      const cv = canvasRef.current;
      if (cv && ctxRef.current) {
        // FIX: Adjust canvas to image ratio
        cv.width = img.naturalWidth;
        cv.height = img.naturalHeight;
        ctxRef.current.drawImage(img, 0, 0);
        setCam({ x: 0, y: 0 });
        setZoom(1);
      }
    };
    img.src = URL.createObjectURL(file);
  };

  const getPos = (e: React.MouseEvent) => {
    const rect = canvasRef.current?.getBoundingClientRect();
    if (!rect) return { x: 0, y: 0 };
    return {
      x: (e.clientX - rect.left - cam.x) / zoom,
      y: (e.clientY - rect.top - cam.y) / zoom
    };
  };

  const startDraw = (e: React.MouseEvent) => {
    if (tool === 'move') return;
    setIsDrawing(true);
    lastPos.current = getPos(e);
  };

  const draw = (e: React.MouseEvent) => {
    if (!isDrawing || !ctxRef.current) return;
    const pos = getPos(e);
    const ctx = ctxRef.current;

    ctx.save();
    if (tool === 'erase') {
      if (bg) {
        // FIX: Eraser restores background correctly
        ctx.drawImage(bg, pos.x - brushSize, pos.y - brushSize, brushSize * 2, brushSize * 2, pos.x - brushSize, pos.y - brushSize, brushSize * 2, brushSize * 2);
      } else {
        ctx.fillStyle = '#1a2810';
        ctx.fillRect(pos.x - brushSize, pos.y - brushSize, brushSize * 2, brushSize * 2);
      }
    } else {
      ctx.strokeStyle = tool === 'water' ? '#1e40af' : tool === 'forest' ? '#166534' : '#22c55e';
      ctx.lineWidth = brushSize;
      ctx.lineCap = 'round';
      ctx.beginPath();
      ctx.moveTo(lastPos.current.x, lastPos.current.y);
      ctx.lineTo(pos.x, pos.y);
      ctx.stroke();
    }
    ctx.restore();
    lastPos.current = pos;
  };

  const handleWheel = (e: React.WheelEvent) => {
    const f = e.deltaY < 0 ? 1.1 : 0.9;
    setZoom(z => Math.max(0.1, Math.min(10, z * f)));
  };

  return (
    <div className="fixed inset-0 flex flex-col bg-[#040608]">
      <div className="h-12 bg-[#040608fb] border-b border-[#22c55e2e] flex items-center px-4 gap-4">
        <div className="font-oswald text-sm font-bold text-[#f59e0b] tracking-widest">üó∫Ô∏è –†–ï–î–ê–ö–¢–û–† –ö–ê–†–¢–ò</div>
        <div className="ml-auto flex gap-2">
          <input type="file" id="bg-up" hidden onChange={handleFile} />
          <button onClick={() => document.getElementById('bg-up')?.click()} className="hud-btn-ed"><ImageIcon size={14} /> –§–æ—Ç–æ</button>
          <button onClick={onBack} className="hud-btn-ed danger">–í–ò–ô–¢–ò</button>
        </div>
      </div>
      <div className="flex-1 flex overflow-hidden">
        <div className="flex-1 relative bg-[#0a0e12] overflow-hidden" onWheel={handleWheel}>
          <div 
            style={{ 
              transform: `translate(${cam.x}px, ${cam.y}px) scale(${zoom})`,
              transformOrigin: '0 0'
            }}
            className="absolute"
          >
            <canvas 
              ref={canvasRef} 
              width={1200} height={800}
              onMouseDown={startDraw}
              onMouseMove={draw}
              onMouseUp={() => setIsDrawing(false)}
              className="cursor-crosshair"
            />
          </div>
          <div className="absolute bottom-4 right-4 text-[10px] text-[#64748b] bg-black/40 px-2 py-1 rounded">
            {Math.round(zoom * 100)}%
          </div>
        </div>
        <div className="w-56 bg-[#040608fb] border-l border-[#22c55e2e] p-4 flex flex-col gap-4">
          <ToolGroup label="–Ü–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∏">
            <ToolBtn active={tool === 'draw'} onClick={() => setTool('draw')} icon={<MousePointer2 size={14} />} label="–ú–∞–ª—é–≤–∞—Ç–∏" />
            <ToolBtn active={tool === 'erase'} onClick={() => setTool('erase')} icon={<Eraser size={14} />} label="–°—Ç–µ—Ä—Ç–∏" />
            <ToolBtn active={tool === 'move'} onClick={() => setTool('move')} icon={<Move size={14} />} label="–ü–∞–Ω / –ó—É–º" />
          </ToolGroup>
          <ToolGroup label="–¢–µ—Ä–µ–Ω">
            <ToolBtn active={tool === 'water'} onClick={() => setTool('water')} icon={<Waves size={14} />} label="–í–æ–¥–∞" color="text-blue-400" />
            <ToolBtn active={tool === 'forest'} onClick={() => setTool('forest')} icon={<TreeDeciduous size={14} />} label="–õ—ñ—Å" color="text-green-500" />
          </ToolGroup>
          <div className="mt-auto">
            <div className="text-[9px] text-[#64748b] mb-2 uppercase">–†–æ–∑–º—ñ—Ä –ø–µ–Ω–∑–ª—è: {brushSize}</div>
            <input type="range" min="4" max="100" value={brushSize} onChange={e => setBrushSize(+e.target.value)} className="w-full" />
          </div>
        </div>
      </div>
    </div>
  );
}

function ToolGroup({ label, children }: any) {
  return (
    <div>
      <div className="text-[9px] text-[#64748b] tracking-[2px] mb-2 uppercase">{label}</div>
      <div className="flex flex-col gap-1">{children}</div>
    </div>
  );
}

function ToolBtn({ active, onClick, icon, label, color }: any) {
  return (
    <button 
      onClick={onClick}
      className={`flex items-center gap-2 px-3 py-2 rounded text-[11px] font-medium transition-all border ${
        active ? 'bg-[#f59e0b1a] border-[#f59e0b4d] text-[#f59e0b]' : 'bg-white/5 border-white/5 text-[#64748b] hover:bg-white/10'
      } ${color || ''}`}
    >
      {icon} {label}
    </button>
  );
}

function toast(msg: string) {
  const t = document.createElement('div');
  t.className = 'fixed bottom-20 left-1/2 -translate-x-1/2 bg-[#080c10] border border-[#22c55e] px-4 py-2 rounded-lg text-[#22c55e] text-xs font-bold z-[9999] shadow-[0_0_20px_rgba(34,197,94,0.2)]';
  t.textContent = msg;
  document.body.appendChild(t);
  setTimeout(() => t.remove(), 2500);
}
